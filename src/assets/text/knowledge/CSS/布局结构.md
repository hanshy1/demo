# 正常文档流
如果你打开一个没有用任何CSS来改变页面布局的网页，那么网页元素就会排列在一个正常流（normal flow）之中。

在正常流中，元素盒子（boxes）会基于文档的写作模式（writing mode）一个接一个地排列。
* 写作模式是水平方向的（句子是从左到右或从右到左书写），正常流会垂直地一个接一个排列页面的块级元素。
* 写作模式是垂直方向的，正常流会水平排列每一个块级元素。

## 通过页面结构来发挥正常文档流的优势
通过确保你书写的页面具有良好的页面结构（well-structured manner），你可以最大程度利用正常流所带来的优势。

# 浮动（Float）
浮动被用来将盒子（box）置于左侧或右侧，同时让内容环绕其展示。
要让一个元素进行浮动，需要为该元素设置一个值为left或right的float属性。默认值为none。
```css
.item {
    float: left;
}
``` 

当你使某个元素浮动并让文字环绕它时，内容的line box被截断了。如果你让一个元素浮动，同时为紧跟着的包含文本的元素设置一个背景色，你会发现背景色会出现在浮动元素下方。
想要在浮动元素和环绕的文本之间创建边距，你需要给浮动元素设置外边距。在文本元素上设置外边距只会让其相对于容器缩进。

## 清除浮动
一旦你对一个元素应用了浮动，所有接下来的元素都会环绕它直到内容处于它下方且开始应用正常文档流。
当你不想要某个元素受到其之前的浮动元素影响时，为其添加clear属性即可。使用left值可以清除左浮动效果，right值为右浮动，both则会清除左右浮动。
```css
.item {
    clear: both;
}
```

# 定位
想要把一个元素从正常流中移除，或者改变其在正常文档流中的位置，可以使用CSS中的position属性。
元素处于正常文档流时，position属性值为static。在块级维度上元素会一个接一个排列下去，滚动时也会和页面一起滚动。

## 相对定位(relative)
如果一个元素具有position: relative; 那么它在正常文档流中的位置会被保留，偏移的参照位是其原先在正常文档流中的位置。可以使用left、top、bottom、right来进行偏移。
```css
.item {
    position: relative;
    left: 50px;
    top: 50px
}
```
相对定位时，元素偏移后的位置不会影响其他元素的布局，但是元素在正常文档流中的位置将被保留。

## 绝对定位(absolute)
如果一个元素具有position: absolute; 那么它将会在正常文档流中移除，偏移的参照位是视口容器，除非这个元素的某个祖先元素也是定位元素(position不为static)，那么将会参照这个祖先元素偏移。

将元素position设置为absolute后，元素会定位在视口的左上角，设置了left、top、bottom、right后，将进行偏移。

如果想让元素移出正常文档流，同时不参照视口定位，而是相对于容器元素定位，那么可以将容器元素position设置为relative。
```css
.container {
    positon: relative;
}

.item {
    position: absolute;
    left: 50px;
    top: 50px;
}
```

## 固定定位(fixed)
如果一个元素具有position: fixed; 那么它将会从正常文档流中被移除，相对于视口定位，页面滚动时，元素不会随着页面一起滚动，而是留在其相对于视口定位的位置。

## sticky 定位
sticky定位会让元素在页面滚动时，随着页面一起滚动，但是滚动到其相对于视口的某个位置时固定在屏幕上，如同fixed一样。
这个属性在旧的浏览器上兼容性较差，在不兼容的浏览器中会被忽略，相当于static。

# 弹性布局(flex)
弹性盒子（Flexbox）布局是一种为一维布局而设计的布局方法。一维的意思是你希望内容是按行或者列来布局。你可以使用display: flex来将元素变为弹性布局。
```css
.container {
    display: flex;
}
```
该容器的直接子元素会变为弹性项（flex item），并按行排列。

## 弹性布局的轴(axis)
弹性盒中元素会按行排列是因为默认的flex-direction值为row，row代表了文本的行文方向。
flex-direction的值被定义为弹性盒子的主轴（main axis）。

交叉轴（cross axis）则是和主轴垂直的一条轴。如果你的flex-direction是row并且弹性项是按照行内方向排列的，那么交叉轴就是块级元素的排列方向。如果flex-direction是column那么弹性项就会以块级元素排列的方向排布，然后交叉轴就会变为row。
```css
.container {
    display: flex;
    flex-direction: row;
}
```
flex-direction设置为row-reverse或column-reverse值可以改变主轴上弹性项的方向。

## 弹性项的大小
通过以下三个属性来控制弹性项在主轴空间上的大小。
* flex-grow
* flex-shrink
* flex-basis

通常可以使用它们的简写形式：flex。第一个值代表flex-grow，第二个是flex-shrink，而第三个则是flex-basis。
```css
.item {
    flex: 1 1 200px;
}
```
flex-basis会为弹性项设置未拉伸和压缩时的初始大小。但是大多数情况下容器元素大小不会正好被分为许多200px大的项，而是有一些不足或剩余空间。flex-grow和flow-shrink属性允许我们在容器大小不足或有空余时控制各个弹性项的大小。

如果flex-grow的值是任意的正数，那么弹性项会被允许拉伸来占据更多的空间。因此，在上面的例子中，当各项被设为200px后，所有多余的空间会被每个弹性项平分并填满。

如果flex-shrink的值为任意的正数，那么当弹性项被设置了flex-basis后，元素溢出容器时会进行收缩。在上面这个CSS的例子中，如果容器空间不足，每个弹性项会等比例缩放以适应容器的大小。

一个具有较大flex-grow值的弹性项会在容器有剩余空间时拉伸更大的比例；而一个具有更大flex-shrink值的项则会在容器空间不足时被压缩的更多。

# 网格布局(grid)
CSS中网格布局是一种用来进行二维布局的技术。二维意味着希望按照行和列来排列内容，使用display: grid;声明网格布局，使用grid-template-columns和grid-template-rows属性来控制网格中的行与列。

display: grid; 容器元素默认设置为块级元素。  
display: inline-grid; 容器元素设置为行内元素。  
注意，设为网格布局以后，容器子元素（项目）的float、display: inline-block、display: table-cell、vertical-align和column-*等设置都将失效。
```css
.container {
    display: grid;
    grid-template-columns: 200px 200px 200px;
    grid-template-rows: 200px 200px;
}
```
这样会生成一个行列元素大小固定的网格。

如果网格很多，可以使用repeat函数定义网格。  
```css
.container {
  display: grid;
  grid-template-columns: repeat(3, 200px);
  grid-template-rows: repeat(3, 200px);
}
```
repeat函数接收的第一个值是重复的次数，第二个值是重复的模式。  
repeat(auto-fill, 200px)，使用auto-fill表示自动填充，这时网格每一列宽度为200，然后自动填充，直到容器不能放置更多的列。  

fr是一种弹性单位，它可以指定网格容器内的空间被如何划分。使用grid-gap来保证元素间的间距。
```css
.container {
  display: grid;
  grid-template-columns: 1fr 1fr 1fr;
  grid-gap: 20px;
}
```

## 网格的自动排列
一旦创建了网格，那么网格的子元素就会一个接一个的放置在单元格中。子元素的放置是依据网格的自动排列规则，不会互相遮盖。
这个顺序由grid-auto-flow属性决定，默认值是row，即"先行后列"。也可以将它设成column，变成"先列后行"。
设为row dense，表示"先行后列"，并且尽可能紧密填满，尽量不出现空格。
设为column dense，表示"先列后行"，并且尽量填满空格。

## 基于行/列的基本定位方法
定位网格元素最简单的方式是使用基于行/列（line）的定位方法，只需告诉浏览器从哪一排到哪一排来进行合并。例如，如果你需要一个2*2的网格区域，你可以将指定元素从第一行开始到第三行、从第一列开始到第三列，这样就可以覆盖到四个单元格。
```css
.item {
    grid-column-start: 1;
    grid-column-end: 3;
    grid-row-start: 1;
    grid-row-end: 3;
}
```
可以用缩写grid-column和grid-row，其中第一个值代表开始位置，第二个值代表结束位置。
```css
.item {
    grid-column: 1 / 3;
    grid-row: 1 / 3;
}
```

## 网格的对齐
### 单元格元素对齐(所有单元格)
可以通过以下属性设置网格元素的对齐方式。
* justify-items 属性 
* align-items 属性 
* place-items 属性

justify-items属性设置单元格内容的水平位置（左中右），align-items属性设置单元格内容的垂直位置（上中下）。
```css
.container {
  justify-items: start | end | center | stretch;
  align-items: start | end | center | stretch;
}
```
这两个属性的写法完全相同，都可以取下面这些值。
* start：对齐单元格的起始边缘。
* end：对齐单元格的结束边缘。
* center：单元格内部居中。
* stretch：拉伸，占满单元格的整个宽度（默认值）。

place-items属性是align-items属性和justify-items属性的合并简写形式。
```css
.container{
    place-items: <align-items> <justify-items>;
}

.container{
    place-items: start end;
}
```
如果省略第二个值，则浏览器默认和第一个值相同。

### 单元格元素对齐(单个单元格)
可以通过以下属性设置单个单元格的对齐方式。
* justify-self 属性
* align-self 属性
* place-self 属性
justify-self属性设置单元格内容的水平位置（左中右），跟justify-items属性的用法完全一致，但只作用于单个项目。
align-self属性设置单元格内容的垂直位置（上中下），跟align-items属性的用法完全一致，也是只作用于单个项目。
```css
.item {
    justify-self: start | end | center | stretch;
    align-self: start | end | center | stretch;
}
```

place-self属性是align-self属性和justify-self属性的合并简写形式。
```css
.item {
    place-self: <align-self> <justify-self>;
}
```
如果省略第二个值，place-self属性会认为这两个值相等。

### 内容区域的对齐
可以通过以下属性设置内容区域的对齐方式。
* justify-content 属性
* align-content 属性
* place-content 属性

justify-content属性是整个内容区域在容器里面的水平位置（左中右），align-content属性是整个内容区域的垂直位置（上中下）。
```css
.container {
  justify-content: start | end | center | stretch | space-around | space-between | space-evenly;
  align-content: start | end | center | stretch | space-around | space-between | space-evenly;  
}
```

这两个属性的写法完全相同，都可以取下面这些值。
* start - 对齐容器的起始边框。
* end - 对齐容器的结束边框。
* center - 容器内部居中。
* stretch - 项目大小没有指定时，拉伸占据整个网格容器。
* space-around - 每个项目两侧的间隔相等。所以，项目之间的间隔比项目与容器边框的间隔大一倍。
* space-between - 项目与项目的间隔相等，项目与容器边框之间没有间隔。
* space-evenly - 项目与项目的间隔相等，项目与容器边框之间也是同样长度的间隔。

place-content属性是align-content属性和justify-content属性的合并简写形式。
```css
.container {
    place-content: <align-content> <justify-content>;
}
```
如果省略第二个值，则浏览器默认和第一个值相同。







