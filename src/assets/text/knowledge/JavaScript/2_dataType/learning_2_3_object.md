# 概述
## 1. 生成方法
简单来说，对象就是一组“键值对”(key-value)的集合，是一种无序的复合数据结构。
```js
var obj = {
    foo: 'a',
    bar: 'b'
}
```
对象obj中的foo称为“键名”，'a'称为“键值”。

## 2. 键名
对象的属性名又可以称为“键名”。  
对象的所有键名都是字符串（ES6中Symbol值也可作为键名），所以加不加引号都可以。  
如果键名是数值，会自动转换为字符串。  
如果键名不符合标识名的条件（比如第一个字符为数字，或者含有空格），且也不是数字，则必须加上引号，否则报错

## 3. 对象的引用
如果不同的变量名指向同一个对象，那么它们都是这个对象的引用，指向这个对象的内存地址。修改一个变量，会影响其他变量。
```js
var o1 = {};
var o2 = o1;

o1.a = 1;
o2.a // 1
```
如果取消某一个变量对于原对象的引用，不会影响到另一个变量。

这种引用仅限于对象，如果两个变量引用原始类型的值，则都是值的拷贝。

## 4. 表达式还是语句
如果行首是一个大括号，它到底是表达式还是语句？
```js
{ foo: 123 }
```
这行代码有两种含义：一是表示一个对象的表达式；二是一个代码块语句，里面有一个标签，指向表达式123。  
为了避免歧义，JS引擎的做法是，遇到这种情况，一律解释为代码块。

如果要解释为对象，最好在大括号外面加上圆括号。因为圆括号里面只能是表达式，所以能确保大括号能解析为对象。
```js
({ foo: 123 }) // { foo: 123 }
({ console.log(123) }) // error
```

这种差异在eval()方法中反映的最明显。
```js
eval('{foo: 123}') // 123
eval('({foo: 123})') // {foo: 123}
```

## 5. 对象属性的读取
对象属性的读取有两种方法：
* 点运算符
* 方括号运算符

```js
var obj = { foo: 123 }
obj.foo // 123
obj['foo'] // 123
```
使用方括号时，对象的键名一定要用引号，否则会识别为变量。数字键名可以不使用引号，因为会自动转换为字符串。  
方括号内可以使用表达式。  
数字键名不能使用点运算符取值，会被当成小数点报错。

## 6. 属性的操作（查看、删除）
可以使用Object.keys()方法查看一个对象的所有属性。

### 1) delete操作符
delete操作符用于删除对象的属性，删除成功后返回true。
```js
var obj = { a: 1, b: 2 }
obj.a  // 1

delete obj.a
obj.a // undefined
```

使用delete删除不存在的属性时，也返回true，所以不能根据返回值结果判断对象是否具有这个属性。

只有在对象具有这个属性，且不能被删除时，delete才会返回false。  
delete只能删除对象自身的属性，不能删除从原型上继承的属性。
```js
var obj = Object.defineProperty({}, 'a', { value: 123, configurable: false })
delete obj.a // false

delete obj.toString // true，但是toString没有被删除
```

### 2) in运算符
in运算符用于检查对象是否包含某个属性，如果包含就返回true，否则返回false。左边是一个字符串，表示属性，右边是一个对象。
```js
var obj = { a: 1}
'a' in obj // true
'toString' in obj // true
```
in运算符的一个问题是它无法判断属性是对象自身的还是继承来的。可以用hasOwnProperty()方法判断是否是自身的属性。
```js
var obj = {};
if ('toString' in obj) {
  console.log(obj.hasOwnProperty('toString')) // false
}
```

### 3) for...in...遍历对象属性
for...in...用来遍历对象的全部属性。有两个注意点。  
* 它遍历的是对象的可遍历属性（enumerable），会跳过不可遍历属性。
* 它不仅遍历对象的自身属性，还遍历继承来的属性。

如果只想遍历对象自身属性，可以使用hasOwnProperty()方法对遍历的属性进行过滤。

### 4) with语句
with语句的格式如下：
```js
with (对象) {
    语句;
}
```

它的作用是操作同一个对象的多个属性时，提供书写的方便。
```js
var obj1 = { a: 1, b: 2 }

with (obj1) {
    a = 3;
    b = 4;
}

// 等同于
obj1.a = 3
obj2.b = 4
```

注意，如果with区块内有变量的赋值操作，必须是当前对象已经存在的属性，否则会创建一个当前作用域全局变量。
```js
var obj = {};
with (obj) {
  p1 = 4;
  p2 = 5;
}

obj.p1 // undefined
p1 // 4
```

这是因为with区块没有改变作用域，它的内部依然是当前作用域。这造成了with语句的一个很大的弊病，就是绑定对象不明确。  
因此，建议不要使用with语句，可以考虑用一个临时变量代替with。
```js
with(obj1.obj2.obj3) {
  console.log(p1 + p2);
}

// 可以写成
var temp = obj1.obj2.obj3;
console.log(temp.p1 + temp.p2);
```
