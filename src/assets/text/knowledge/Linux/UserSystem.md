# 用户系统
linux系统是一个多用户多任务的分时操作系统，任何一个要使用系统资源的用户，都必须首先向系统管理员申请一个账号，然后以这个
账号的身份进入系统。  
用户的账号一方面可以帮助系统管理员对使用系统的用户进行跟踪，并控制他们对资源的访问；另一方面也可以帮助用户组织文件，
并为用户提供安全性保护。

## 用户分类
linux上用户分为以下3类：
* 管理员：root用户，系统管理员，具有所有权限。
* 系统用户：管理系统运行服务，系统中系统服务由不同用户运行，更加安全，默认被限制登录系统。
* 普通用户：用于日常工作而不能管理系统的用户，具有一部分权限。

## UID
每个用户都有一个ID号，称为UID，操作系统通过UID来识别用户。可以用cat /etc/passwd 查看用户信息。
> root:x:0:0:root:/root:/bin/bash
> user:x:1000:1000:xxxx:/home/user:/bin/bash

每行用户信息都以“:”分隔，划分为7个字段：
```
用户名:密码:UID:GID:描述信息:主目录:默认shell
```

UID范围：
* 管理员（root）：0。
* 系统用户：1-999。
* 普通用户：1000以上。
* 来宾账号：65534，这个用户的权限会进一步被限制，用来实现来宾账号。

系统通过UID来认定用户权限而不是名字。如果把普通用户的UID改为0，那么系统会把该用户视作管理员。

## GID
用户组是具有相同特征的用户的逻辑集合。将用户分组是Linux系统中对用户进行管理和控制访问权限的一种手段，系统可以对一个用户组
中的所有用户进行集中管理。不同Linux系统对用户组的规定有所不同，如Linux下的用户属于与他同名的用户组，这个用户组在创建用户时
同时创建。

每个用户在被创建时都会创建一个默认组（其GID和UID相同，叫作基本组或初始组），而后加入的组叫作扩展组或附加组。

GID是用户组的编号，可以用cat /etc/group 查看用户组信息。
> root:x:0:
> sudo:x:27:user
> user:x:1000:

每行信息都以“:”分隔，划分为4个字段：
```
组名:密码:GID:成员列表
```

每一行都是一个用户组的信息，组中的成员列表只包括附加用户，如果该组是某个用户的初始组，这个用户不会出现在成员列表中。
root和创建的普通用户user用户组中都没有多余的成员，sudo组中包含user成员，所以user可以使用sudo命令。

## 进程中的用户管理（PID与UID、GID的关系）
每个进程都拥有真实的用户和组（UID、GID），有效的用户、组（EUID、EGID），特殊权限的控制访问（SUID、SGID），还有Linux中专门负责文件存取的用户、组（FSUID、FSGID，UNIX中没有这两个ID）。

* 真实用户、组（uid、gid）：进程的真正拥有者。每当用户在终端登录时，都会将登录用户作为登录进程的真实拥有者。通过getuid来获得进程的真实拥有者，通过setuid、seteuid、setresuid、setreuid可以修改进程的真实拥有者。
* 有效用户、组（euid、egid）：进程的有效用户和组。进程执行各种操作所允许的权限是根据有效用户、组来判断的。
* 文件系统的用户、组（fsuid、fsgid）：用于进行文件访问的用户、组。这是linux中引入的一类用户、组，在unix中是通过euid、egid来判断文件的访问权限。
* 特殊权限的访问控制（suid、sgid）：用于还原有效用户、组。

## 特殊权限的访问控制(setuid和setgid)
必须有一种方法，允许用户执行那些只有超级用户或管理员才有读写权限的程序或命令。
* set-user-id(SUID)：设定时，文件执行时将以文件拥有者身份执行，而非普通用户的身份。
* set-group-id(SGID)：设定时，文件执行时将以文件的组的身份执行，而非普通用户的身份。
* sticky(s)：粘滞位，如果对目录设置该权限，该目录可以被其他用户读写，只有文件拥有者和root管理员才有权限删除。

### 设置UID
SUID：置于u的x位，原位置有执行权限，就置为s，否则置为S。
```sh
$chmod u+s xxx # 设置setuid权限
$chmod 4551 xxx # r-sr-x--x 使用数字模式的设置方法是，在3个权限位前加数字4
```

### 设置GID
SGID：置于g的x为，原位置有执行权限，就置为s，否则置为S。
```sh
$chmod g+s xxx # 设置setgid权限
$chmod 2551 xxx # r-xr-s--x 使用数字模式的设置方法是，在3个权限位前加数字2
```

### 设置粘滞位STICKY
STICKY：粘滞位，置于o的x位，原位置有执行权限，就置为t，否则为T。
```sh
$chmod o+t xxx # 设置粘滞位
$chmod 1551 xxx # r-xr-x--t 使用数字模式的设置方法是，在3个权限位前加数字1
```
使用chmod命令移除setuid、setgid、sticky权限位的方法是，在3个权限位前加数字0。

## 权能体系(Capabilities)
Capabilities之前：
* 特权操作：只有root用户有特权操作，root拥有所有特权操作。
* 普通用户实现特权操作（setuid），只能是临时获得root权限（所有特权操作）。
* setuid工作过程：  
    ls -l /bin/ping，文件属主是root，表明只有root可以执行ping。  
    但是SUID=1，表明该程序设置了SUID位，则普通用户可以代表root执行此程序。  
    也就是普通用户临时获得了root权限，可以执行ping操作。  
    事实上ping操作只需要网络权限，并不需要其他权限，普通用户执行ping操作就可以临时获得root特权，违反了最小权限原则。

Capabilities的目的：
* 分割root权限：将曾经的root特权分割为单独的unit，每一个都是一个capability，负责一个特权操作，共38种权能。
* 最小能力集：  
    传统setuid，会让某些进程获得root特权，现在只需给予特定权限。  
    ping需要CAP_NET_RAW权限，是一个setuid程序。  
    chmod u-s /bin/ping （去掉suid位）  
    setfcaps -c cap_net_raw=p -e /bin/ping （给ping设置cap_net_raw网络权限）